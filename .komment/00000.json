[
  {
    "name": "app.py",
    "path": "superlinked_app/app.py",
    "content": {
      "structured": {
        "description": "And instantiates various data structures and components in Superlinked's framework for natural language processing and information retrieval. It includes schema definitions for product and user entities, an event schema, space definitions for text and number embeddings, event weights, an index with associated effects, a query object, and sources for restful API endpoints. The code also sets up a vector database connection to Redis and registers the components in the Superlinked registry.",
        "items": [
          {
            "id": "89f60bdb-2a9f-4b81-8f4a-af4001ab1291",
            "ancestors": [],
            "description": "Defines a data schema for product information. It includes fields for description, name, category, price, review count, and rating, as well as an ID field. This schema outlines the structure and type of data for each product attribute.",
            "attributes": [
              {
                "name": "description",
                "type_name": "String",
                "description": "Mandatory as it has no default value assigned. It represents a description of the product."
              },
              {
                "name": "name",
                "type_name": "String",
                "description": "Required to hold a name for the product. It can be any string value, without any specific length or format restriction."
              },
              {
                "name": "category",
                "type_name": "String",
                "description": "Described as a category of the product, likely representing a broad or narrow classification within a product hierarchy."
              },
              {
                "name": "price",
                "type_name": "Integer",
                "description": "Represented as a whole number with no decimal places, indicating the monetary value of a product."
              },
              {
                "name": "review_count",
                "type_name": "Integer",
                "description": "Intended to store the count of reviews for a product."
              },
              {
                "name": "review_rating",
                "type_name": "Integer",
                "description": "A representation of the average rating given by customers for a product based on their reviews."
              },
              {
                "name": "id",
                "type_name": "IdField",
                "description": "Part of the schema for products. It represents a unique identifier for each product, likely used to identify or link to specific products within the system."
              }
            ],
            "name": "ProductSchema",
            "location": {
              "start": 27,
              "insert": 29,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 9,
            "docLength": null
          },
          {
            "id": "bb0076cb-458d-ddb9-1643-b2677fd3f953",
            "ancestors": [],
            "description": "Defines a schema for user preferences, comprising four fields: `preference_description`, `preference_name`, `preference_category`, and `id`. This schema provides a structured format for storing and managing user preferences.",
            "attributes": [
              {
                "name": "preference_description",
                "type_name": "String",
                "description": "Used to describe a user's preference."
              },
              {
                "name": "preference_name",
                "type_name": "String",
                "description": "Part of the schema definition for user preferences. It likely represents a descriptive name or label for a user's preference, such as \"Favorite Color\" or \"Preferred Language\"."
              },
              {
                "name": "preference_category",
                "type_name": "String",
                "description": "Part of a user's preferences, likely categorizing their specific preference (e.g., music genre)."
              },
              {
                "name": "id",
                "type_name": "IdField",
                "description": "A unique identifier for each user object."
              }
            ],
            "name": "UserSchema",
            "location": {
              "start": 37,
              "insert": 39,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 6,
            "docLength": null
          },
          {
            "id": "abba30eb-076d-e186-494c-6683fd7c9cd1",
            "ancestors": [],
            "description": "Defines a schema for representing events, which can be products or user-related actions. It contains fields for product and user references, event type, unique ID, and creation timestamp. This schema provides structure for storing and querying events in a database or API response.",
            "attributes": [
              {
                "name": "product",
                "type_name": "SchemaReference[ProductSchema]",
                "description": "Referenced from another schema, indicating that it represents a reference to a ProductSchema object."
              },
              {
                "name": "user",
                "type_name": "SchemaReference[UserSchema]",
                "description": "Referenced from a UserSchema."
              },
              {
                "name": "event_type",
                "type_name": "String",
                "description": "Part of the schema definition for events. It represents the type of event being recorded."
              },
              {
                "name": "id",
                "type_name": "IdField",
                "description": "Implicitly considered as a unique identifier for each event instance, allowing it to be uniquely identified and referenced throughout the system."
              },
              {
                "name": "created_at",
                "type_name": "CreatedAtField",
                "description": "Expected to be present in all instances of this schema. Its presence suggests that it stores information related to when the event was created, likely as a timestamp."
              }
            ],
            "name": "EventSchema",
            "location": {
              "start": 44,
              "insert": 46,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 7,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "Superlinked Server Sink/main.py",
    "content": {
      "structured": {
        "description": "An application that consumes events from a Kafka topic and sends data to a Superlinked endpoint. It utilizes the QuixStreams library for handling Kafka consumption and produces random event IDs and timestamps using built-in functions. The sent data is logged and error messages are recorded in a file if the response is not 202.",
        "items": [
          {
            "id": "dfae01fe-c53c-eb99-0f4e-9fa5ee8e2270",
            "ancestors": [],
            "description": "Sends a POST request to Superlinked's API with data from a dictionary, including user and product information, a randomly generated event ID, and a current timestamp. It prints the response status code and text, logging errors if the response is not 202.",
            "params": [
              {
                "name": "data",
                "type_name": "dict",
                "description": "Expected to contain keys named 'user', 'product' and 'event_type'."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "data = {'user': 'john', 'product': 'apple', 'event_type': 'purchase'}\nsend_data_to_superlinked(data)",
              "description": ""
            },
            "name": "send_data_to_superlinked",
            "location": {
              "start": 26,
              "insert": 28,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 23,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "ingest-events/main.py",
    "content": {
      "structured": {
        "description": "A Quix Streams application that simulates user-product interactions and publishes events to a Kafka topic. It uses randomization to generate product IDs, event types, users, and timestamps, then appends these events to an in-memory history for each unique combination of user-product. The events are published to the Kafka topic using the Quix Streams producer.",
        "items": []
      }
    }
  },
  {
    "name": "main.py",
    "path": "Streamlit Recommendations Dash/main.py",
    "content": {
      "structured": {
        "description": "A Streamlit application that fetches real-time recommendations from an API based on user input and weights for different criteria. The app allows users to select a user ID, set weights for description, category, name, price, review count, and review rating, and then displays the recommended data in a pandas dataframe.",
        "items": [
          {
            "id": "34982d12-f86b-eeb9-c04b-5ff4d51f84b2",
            "ancestors": [],
            "description": "Retrieves data from a URL using a POST request with JSON payload, containing parameters such as user ID and weights for different categories. It processes the response, extracting relevant data into a Pandas DataFrame, which is then returned if the request is successful, or an empty DataFrame otherwise.",
            "params": [
              {
                "name": "user_id",
                "type_name": "int | str",
                "description": "Required for making a POST request to a specified URL with the provided payload, which includes the user ID and other query parameters."
              }
            ],
            "returns": {
              "type_name": "pdDataFrame",
              "description": "A two-dimensional labeled data structure with columns of potentially different types. If an error occurs during API call, it returns an empty DataFrame."
            },
            "usage": {
              "language": "python",
              "code": "df = get_data(12345)",
              "description": ""
            },
            "name": "get_data",
            "location": {
              "start": 20,
              "insert": 21,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "da1300ba-42b8-14b0-e04b-999a975d15e3",
            "ancestors": [],
            "description": "Retrieves cached data for a given user ID and set of weights, passing these parameters to the `get_data` function and returning its result.",
            "params": [
              {
                "name": "user_id",
                "type_name": "any",
                "description": "Used to retrieve data. It seems that this value corresponds to a unique identifier for each user in the system."
              },
              {
                "name": "description_weight",
                "type_name": "int | float",
                "description": "Used as an input to the internal `get_data` function along with other parameters to retrieve data related to user ID."
              },
              {
                "name": "category_weight",
                "type_name": "int | float",
                "description": "Used as an input to the `get_data` function. Its purpose is not explicitly defined, but based on its name and usage alongside other weights, it likely represents the relative importance or relevance of a product's category in the calculation."
              },
              {
                "name": "name_weight",
                "type_name": "float",
                "description": "Used to weight the importance of name attribute in the data retrieved by the `get_data` function."
              },
              {
                "name": "price_weight",
                "type_name": "float | int",
                "description": "Used to specify the relative importance of price when calculating the weighted average score for a product."
              },
              {
                "name": "review_count_weight",
                "type_name": "int",
                "description": "Used to control how much weight should be given to the review count while ranking products for a user."
              },
              {
                "name": "review_rating_weight",
                "type_name": "float",
                "description": "Part of the input data to calculate weighted scores for user profiles."
              }
            ],
            "returns": {
              "type_name": "object",
              "description": "Returned from calling `get_data(user_id, description_weight, category_weight, name_weight, price_weight, review_count_weight, review_rating_weight)`."
            },
            "usage": {
              "language": "python",
              "code": "result = get_cached_data(1, 0.5, 0.2, 0.3, 0.4, 0.1, 0.6)",
              "description": ""
            },
            "name": "get_cached_data",
            "location": {
              "start": 96,
              "insert": 98,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 3,
            "docLength": null
          },
          {
            "id": "e83e9dc6-7ef8-6c95-1740-56240adca2b3",
            "ancestors": [],
            "description": "Retrieves data from a server using a POST request, based on user-provided weights for different attributes. It returns a pandas DataFrame containing the extracted data if the request is successful; otherwise, it displays an error message and returns an empty DataFrame.",
            "params": [
              {
                "name": "user_id",
                "type_name": "int",
                "description": "Used as part of the payload when making an HTTP POST request to a specified URL. It represents the unique identifier of a user."
              },
              {
                "name": "description_weight",
                "type_name": "float",
                "description": "Used to specify the weight of the description attribute when querying data. It represents how important the description field is for the query results."
              },
              {
                "name": "category_weight",
                "type_name": "float",
                "description": "Part of a payload to be sent in a POST request to an unspecified URL (`url`). Its value determines the weightage given to the category while processing data."
              },
              {
                "name": "name_weight",
                "type_name": "float",
                "description": "Assigned to a key-value pair in the `payload` dictionary with a default value \"name_weight\". Its purpose is likely to indicate the relative importance of product name in search query."
              },
              {
                "name": "price_weight",
                "type_name": "float",
                "description": "Used to specify the weightage given to price while generating the query."
              },
              {
                "name": "review_count_weight",
                "type_name": "int",
                "description": "Used to specify the weight given to review count when querying data."
              },
              {
                "name": "review_rating_weight",
                "type_name": "float",
                "description": "Used to specify the weightage given to review ratings while calculating the ranking of search results."
              }
            ],
            "returns": {
              "type_name": "pdDataFrame",
              "description": "A two-dimensional table of data (similar to an Excel spreadsheet) that can be used for analysis and manipulation. The DataFrame contains extracted data from the response, if the request was successful. Otherwise, it returns an empty DataFrame."
            },
            "usage": {
              "language": "python",
              "code": "user_id = 1234\ndescription_weight = 0.5\ncategory_weight = 0.3\nname_weight = 0.1\nprice_weight = 0.05\nreview_count_weight = 0.05\nreview_rating_weight = 0.1\n\ndata = get_data(user_id, description_weight, category_weight, name_weight, price_weight, review_count_weight, review_rating_weight)",
              "description": ""
            },
            "name": "get_data",
            "location": {
              "start": 101,
              "insert": 102,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 25,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main_backup.py",
    "path": "Streamlit Recommendations Dash/main_backup.py",
    "content": {
      "structured": {
        "description": "A web application using Streamlit that provides real-time recommendations based on user input and query parameters. It uses the Superlinked API to fetch data and pandas for data manipulation. The application features a dropdown menu for selecting users, sliders for adjusting weights of different criteria (description, category, name, price, review count, and review rating), and a countdown timer that refreshes the recommendation every 10 seconds.",
        "items": [
          {
            "id": "c9b7a26e-aa60-509e-7346-4d9d6dc22ee6",
            "ancestors": [],
            "description": "Retrieves data based on a given user ID by sending a POST request to a specified URL, parses the response JSON, extracts relevant information into a pandas DataFrame, and returns it. If the request fails, it displays an error message and returns an empty DataFrame.",
            "params": [
              {
                "name": "user_id",
                "type_name": "int | str",
                "description": "Used to construct a payload that contains information about the user for which data needs to be retrieved. It is required as part of the payload."
              }
            ],
            "returns": {
              "type_name": "pdDataFrame|pdDataFrame",
              "description": "A DataFrame object if the request to the server is successful and it returns an empty DataFrame otherwise, indicating that the request failed or no data was extracted."
            },
            "usage": {
              "language": "python",
              "code": "user_id = 12345\ndf = get_data(user_id)\n",
              "description": ""
            },
            "name": "get_data",
            "location": {
              "start": 20,
              "insert": 21,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "124ce408-e197-b0bc-ec47-d4622161bda7",
            "ancestors": [],
            "description": "Retrieves and returns cached data for a given set of input parameters. It calls another function `get_data` with the same parameters, likely to fetch new data if it's not already cached or outdated.",
            "params": [
              {
                "name": "user_id",
                "type_name": "any",
                "description": "Used as input to retrieve cached data from the user's profile. Its value determines which user's data will be retrieved."
              },
              {
                "name": "description_weight",
                "type_name": "float",
                "description": "Used to specify the relative importance or weight of product description when calculating a weighted average score."
              },
              {
                "name": "category_weight",
                "type_name": "int",
                "description": "Used to determine the weightage given to category information when calculating similarity scores for filtering data based on user preferences."
              },
              {
                "name": "name_weight",
                "type_name": "float",
                "description": "Used as a weight for the name attribute when retrieving data using the `get_data` function. It specifies how important the name attribute is relative to other attributes in the calculation."
              },
              {
                "name": "price_weight",
                "type_name": "float",
                "description": "Used to weight the importance of the product's price when calculating its overall score. It represents the relative significance of price compared to other factors."
              },
              {
                "name": "review_count_weight",
                "type_name": "int",
                "description": "Used to determine the weight given to the number of reviews when calculating the weighted average score for a product."
              },
              {
                "name": "review_rating_weight",
                "type_name": "float",
                "description": "7th in sequence among other weights, likely representing the weightage given to review ratings in a data retrieval process."
              }
            ],
            "returns": {
              "type_name": "Any",
              "description": "Cached result from a call to `get_data`. This caching allows for faster execution when the same inputs are provided again."
            },
            "usage": {
              "language": "python",
              "code": "result = get_cached_data(123, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6)",
              "description": ""
            },
            "name": "get_cached_data",
            "location": {
              "start": 96,
              "insert": 98,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 3,
            "docLength": null
          },
          {
            "id": "71c9a616-71d7-4da4-4846-4fe09756f30c",
            "ancestors": [],
            "description": "Runs a POST request to a specified URL with a payload containing various weights and returns a pandas DataFrame containing extracted data if the response is successful, otherwise it displays an error message and returns an empty DataFrame.",
            "params": [
              {
                "name": "user_id",
                "type_name": "int",
                "description": "Likely used to filter or retrieve data based on a specific user's ID from an external database or API."
              },
              {
                "name": "description_weight",
                "type_name": "float",
                "description": "Used to specify the relative importance or relevance of the product description in the query. It is one of the factors considered when processing the user's request."
              },
              {
                "name": "category_weight",
                "type_name": "float",
                "description": "Part of the payload sent to the requests.post method. It represents the weightage given to category in the query."
              },
              {
                "name": "name_weight",
                "type_name": "float",
                "description": "Part of the payload being sent to the server as JSON. It represents the weight assigned to the name field in the query."
              },
              {
                "name": "price_weight",
                "type_name": "int",
                "description": "6th in the list of parameters passed to the function. It represents the weight assigned to price when calculating a score for search results."
              },
              {
                "name": "review_count_weight",
                "type_name": "int",
                "description": "Part of the payload sent with the POST request to the specified URL. It represents the weight given to review count while evaluating query results."
              },
              {
                "name": "review_rating_weight",
                "type_name": "float",
                "description": "Used to determine the weight given to review ratings when calculating the overall score for a query result."
              }
            ],
            "returns": {
              "type_name": "pdDataFrame|pdDataFrame",
              "description": "Empty if the request fails otherwise, it contains extracted data from a response."
            },
            "usage": {
              "language": "python",
              "code": "user_id = \"12345\"\ndescription_weight = 0.5\ncategory_weight = 0.3\nname_weight = 0.1\nprice_weight = 0.05\nreview_count_weight = 0.15\nreview_rating_weight = 0.01\n\ndf = get_data(user_id, description_weight, category_weight, name_weight, price_weight, review_count_weight, review_rating_weight)\n",
              "description": ""
            },
            "name": "get_data",
            "location": {
              "start": 101,
              "insert": 102,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "Flask Web Gateway/main.py",
    "content": {
      "structured": {
        "description": "A RESTful API using Flask that consumes JSON data from POST requests and produces it to a Kafka topic using QuixStreams. It also sets up logging with a custom logger instance. The API is served by Waitress and can be accessed at localhost:80.",
        "items": [
          {
            "id": "f2f9871b-c621-8f94-4845-d12995990c7f",
            "ancestors": [],
            "description": "Handles POST requests to `/data/`. It extracts JSON data from the request, logs a message and sends the data to a Kafka topic using `producer.produce`, then returns a successful response with CORS enabled.",
            "params": [],
            "returns": {
              "type_name": "Response",
              "description": "200 status code, allowing any origin to access this resource via CORS headers."
            },
            "usage": {
              "language": "python",
              "code": "requests.post(\"http://localhost:5000/data/\", json={\"key\": \"value\", \"sessionId\": \"12345\"})",
              "description": ""
            },
            "name": "post_data",
            "location": {
              "start": 27,
              "insert": 30,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 15,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "setup_logging.py",
    "path": "Flask Web Gateway/setup_logging.py",
    "content": {
      "structured": {
        "description": "A function that initializes and returns a custom logger named 'waitress' using Python's built-in logging package. The logger is set to log at the INFO level, with messages propagated only to this logger. A console handler is also created and added to the logger, formatting each log message as a timestamp, logger name, log level, and message.",
        "items": [
          {
            "id": "a2b1e50c-49b8-7799-d14d-f910951cbdbb",
            "ancestors": [],
            "description": "Initializes a logger named 'waitress' with a level of INFO, and configures it to log messages to the console with a specified format. The propagate flag is set to False to prevent logging messages from being passed on to higher-level handlers.",
            "params": [],
            "returns": {
              "type_name": "loggingLogger",
              "description": "An instance of the Logger class from the Python standard library module `logging`. This object represents a single thread's execution of the logging module, and it can be used to log messages."
            },
            "usage": {
              "language": "python",
              "code": "logger = get_logger()\nlogger.info(\"This message will be printed in the console\")",
              "description": ""
            },
            "name": "get_logger",
            "location": {
              "start": 4,
              "insert": 6,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 9,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "MotherDuck Write/main.py",
    "content": {
      "structured": {
        "description": "An application using Quix Streams that consumes data from a Kafka topic, processes it as a streaming DataFrame, and writes the results to a table in a MotherDuck database. The table is created if it does not exist. Data is inserted into the table or updated if the page_id already exists.",
        "items": [
          {
            "id": "b51fa580-f30e-f38b-4247-7f1692368f3c",
            "ancestors": [],
            "description": "Inserts data into a database table named `{tablename}` with columns `page_id` and `count`. If a record with the same `page_id` already exists, it updates the existing record by setting its `count` value to the new one provided in `msg['action_count']`.",
            "params": [
              {
                "name": "con",
                "type_name": "sqlite3.Connection",
                "description": "Used to execute SQL commands on a SQLite database. It represents a connection to the database that can be used for querying, creating or modifying data within the database."
              },
              {
                "name": "msg",
                "type_name": "Dict[str, Union[int, str]]",
                "description": "Expected to contain at least two key-value pairs: 'page_id' with an integer value, 'action_count' with an integer value."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "tablename = \"my_table\"\nmsg = {\"page_id\": 123, \"action_count\": 456}\ninsert_data(conn, msg)",
              "description": ""
            },
            "name": "insert_data",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 7,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "User Actions Generator/main.py",
    "content": {
      "structured": {
        "description": "An application that publishes events to a Kafka topic using Quix Streams. It creates a producer object and uses it to produce records with user actions (view, hover, scroll, click) and their corresponding timestamps, page IDs, and user IDs. The records are then published to the specified Kafka topic at random intervals.",
        "items": [
          {
            "id": "777fe04c-717f-df9d-834f-10dfa26b9e90",
            "ancestors": [],
            "description": "Generates random user and page data, converts it to JSON, publishes it to a topic using an Apache Kafka producer, and logs the publication process. The frequency of publications is random between 0.1 and 1 second.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "if __name__ == '__main__':\n    main()\n",
              "description": ""
            },
            "name": "main",
            "location": {
              "start": 21,
              "insert": 22,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 23,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "Streamlit Real-time MotherDuck/main.py",
    "content": {
      "structured": {
        "description": "A real-time dashboard using Streamlit and Bokeh that retrieves data from a MotherDuck database through a service token. The dashboard displays a dynamically updating bar chart showing page view counts and a table underneath, both of which are refreshed periodically. The data is fetched using a cached function that queries the database for page IDs and their corresponding counts, then caches the result to improve performance.",
        "items": [
          {
            "id": "47f89b71-0016-03bd-7447-e4cb314b8b83",
            "ancestors": [],
            "description": "Executes a SQL query on a database connection (`conn`) and returns the result as a pandas DataFrame (`df`). The query selects `page_id` and `count` from a table named by `table_name`, ordered by `page_id` in ascending order, and prints the execution time.",
            "params": [],
            "returns": {
              "type_name": "pandasDataFrame",
              "description": "A data structure that contains tabular data."
            },
            "usage": {
              "language": "python",
              "code": "data = get_data()\n",
              "description": "\nNote: The above code does not include any import statement for datetime and table_name variables as it seems to be already defined in the context of the program."
            },
            "name": "get_data",
            "location": {
              "start": 23,
              "insert": 24,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "191acc70-f911-6ab3-274a-191f5b58d92f",
            "ancestors": [],
            "description": "Retrieves cached data by calling `get_data`. It utilizes the `@st.cache_data` decorator, which caches the output of the decorated function for subsequent calls with the same arguments. This approach enhances performance and reduces computational overhead by reusing cached results.",
            "params": [],
            "returns": {
              "type_name": "Any",
              "description": "Retrieved by calling the function `get_data`. The return value may be cached to speed up subsequent calls."
            },
            "usage": {
              "language": "python",
              "code": "result = get_cached_data()\n# Use result as needed\n",
              "description": ""
            },
            "name": "get_cached_data",
            "location": {
              "start": 30,
              "insert": 32,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  }
]